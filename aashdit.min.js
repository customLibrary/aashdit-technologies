document.addEventListener("DOMContentLoaded", function () {
  /* ========= Ripple Buttons ========= */
  document.querySelectorAll(".aash-btn").forEach((btn) => {
    btn.addEventListener("click", function (e) {
      const ripple = document.createElement("span");
      ripple.classList.add("aash-ripple");
      const size = Math.max(this.offsetWidth, this.offsetHeight);
      ripple.style.width = ripple.style.height = size + "px";
      const rect = this.getBoundingClientRect();
      ripple.style.left = e.clientX - rect.left - size / 2 + "px";
      ripple.style.top = e.clientY - rect.top - size / 2 + "px";
      this.appendChild(ripple);
      setTimeout(() => ripple.remove(), 600);
    });
  });

  /* ========= Modal ========= */
  document.querySelectorAll('[data-toggle="aash-modal"]').forEach((btn) => {
    btn.addEventListener("click", () => {
      const target = btn.getAttribute("data-target");
      const modal = document.querySelector(target);
      if (modal) modal.classList.add("show");
    });
  });

  document.querySelectorAll('[data-close="aash-modal"]').forEach((btn) => {
    btn.addEventListener("click", () => {
      const modal = btn.closest(".aash-modal");
      if (modal) modal.classList.remove("show");
    });
  });

  /* ========= Select (Single & Multi) ========= */
  document.querySelectorAll(".aash-select-single").forEach((select) => {
    const display = select.querySelector(".aash-select-display");
    const placeholder = select.querySelector(".aash-placeholder");
    const chipsContainer = select.querySelector(".aash-chips");
    const dropdown = select.querySelector(".aash-select-dropdown");
    const searchInput = dropdown.querySelector("input");
    const optionsWrapper = dropdown.querySelector(".aash-options");
    const noOptions = dropdown.querySelector(".aash-no-options");

    // Toggle dropdown
    display.addEventListener("click", (e) => {
      e.stopPropagation();
      const isOpen = select.classList.contains("open");
      document.querySelectorAll(".aash-select-single").forEach((s) => {
        s.classList.remove("open");
        s.querySelector(".aash-select-dropdown").style.display = "none";
      });
      if (!isOpen) {
        select.classList.add("open");
        dropdown.style.display = "block";
        searchInput.value = "";
        optionsWrapper
          .querySelectorAll(".aash-option")
          .forEach((opt) => (opt.style.display = ""));
        noOptions.style.display = "none";
        searchInput.focus();
      }
    });

    // Close when clicking outside
    document.addEventListener("click", (e) => {
      if (!select.contains(e.target)) {
        select.classList.remove("open");
        dropdown.style.display = "none";
      }
    });

    // Filter
    searchInput.addEventListener("input", () => {
      const filter = searchInput.value.toLowerCase();
      let matchCount = 0;
      optionsWrapper.querySelectorAll(".aash-option").forEach((opt) => {
        const text = opt.textContent.toLowerCase();
        if (text.includes(filter)) {
          opt.style.display = "";
          matchCount++;
        } else {
          opt.style.display = "none";
        }
      });
      noOptions.style.display = matchCount ? "none" : "block";
    });

    // Single select
    if (select.dataset.type === "single") {
      const hiddenInput = select.querySelector('input[type="hidden"]');
      optionsWrapper.querySelectorAll(".aash-option").forEach((opt) => {
        opt.addEventListener("click", () => {
          const value =
            opt.getAttribute("data-value") || opt.textContent.trim();
          optionsWrapper
            .querySelectorAll(".aash-option")
            .forEach((o) => o.classList.remove("selected"));
          opt.classList.add("selected");
          placeholder.textContent = opt.textContent.trim();
          placeholder.style.color = "#000";
          if (hiddenInput) hiddenInput.value = value;
          select.dataset.value = value;
          select.classList.remove("open");
          dropdown.style.display = "none";
        });
      });
    }

    // Multi select (chips)
    if (select.dataset.type === "multi") {
      const hiddenInput = select.querySelector('input[type="hidden"]');

      const updateHiddenInput = () => {
        const values = [...chipsContainer.children].map(
          (chip) => chip.dataset.value
        );
        hiddenInput.value = values.join(",");
      };

      optionsWrapper
        .querySelectorAll(".aash-option input[type='checkbox']")
        .forEach((cb) => {
          cb.addEventListener("change", () => {
            const value = cb.value;
            const label = cb.parentElement.textContent.trim();

            if (cb.checked) {
              // add chip
              const chip = document.createElement("div");
              chip.className = "aash-chip";
              chip.dataset.value = value;
              chip.innerHTML = `${label} <span class="remove">&times;</span>`;
              chip.querySelector(".remove").addEventListener("click", () => {
                chip.remove();
                cb.checked = false;
                if (!chipsContainer.children.length) {
                  placeholder.style.display = "inline";
                }
                updateHiddenInput();
              });
              chipsContainer.appendChild(chip);
              placeholder.style.display = "none";
            } else {
              // remove chip
              const chip = [...chipsContainer.children].find(
                (c) => c.dataset.value === value
              );
              if (chip) chip.remove();
              if (!chipsContainer.children.length) {
                placeholder.style.display = "inline";
              }
            }

            updateHiddenInput();
          });
        });
    }
  });

  /* ========= Form Controls (floating labels) ========= */
  document.querySelectorAll(".aash-form-control").forEach((control) => {
    const select = control.querySelector(".aash-select");
    if (!select) return;

    // Focus → move label up
    select.addEventListener("focus", () => {
      control.classList.add("focused");
    });

    // Blur → check value
    select.addEventListener("blur", () => {
      control.classList.remove("focused");
      if (select.value) {
        control.classList.add("has-value"); // keep label up
      } else {
        control.classList.remove("has-value"); // reset
      }
    });

    // Change → keep label up if value is chosen
    select.addEventListener("change", () => {
      if (select.value) {
        control.classList.add("has-value");
      } else {
        control.classList.remove("has-value");
      }
    });

    // Initial state (if pre-filled)
    if (select.value) {
      control.classList.add("has-value");
    }
  });
  /* ========= Nav and Tabs js here ========= */
  document.querySelectorAll(".aash-nav").forEach((nav) => {
    const navLinks = nav.querySelectorAll(".aash-nav-link");
    const tabContent = nav.nextElementSibling; // assumes tab-content is next sibling
    const tabPanes = tabContent.querySelectorAll(".tab-pane");

    navLinks.forEach((link) => {
      link.addEventListener("click", (e) => {
        e.preventDefault();

        // Remove active class from all links in this nav
        navLinks.forEach((l) =>
          l.classList.remove(
            "active",
            "active-primary",
            "active-success",
            "active-warning"
          )
        );

        // Add active class to clicked link
        if (link.dataset.color) {
          link.classList.add(link.dataset.color); // if using colored outline
        } else {
          link.classList.add("active"); // filled nav
        }

        // Show corresponding tab content
        tabPanes.forEach((pane) => {
          pane.classList.toggle(pane.dataset.tab === link.dataset.tab);
          if (pane.dataset.tab === link.dataset.tab)
            pane.classList.add("active");
          else pane.classList.remove("active");
        });
      });
    });
  });

  // Tooltip initializer
  document.querySelectorAll("[data-tooltip]").forEach((btn) => {
    const title = btn.getAttribute("data-title");
    const placement = btn.getAttribute("data-placement") || "top";

    const tooltip = document.createElement("div");
    tooltip.className = "aash-tooltip";
    tooltip.innerText = title;
    tooltip.setAttribute("data-placement", placement);
    document.body.appendChild(tooltip);

    btn.addEventListener("mouseenter", () => {
      tooltip.classList.add("show");

      tooltip.style.left = "-9999px";
      tooltip.style.top = "-9999px";
      tooltip.getBoundingClientRect();

      const rect = btn.getBoundingClientRect();
      const tipRect = tooltip.getBoundingClientRect();
      const gap =
        parseInt(
          getComputedStyle(document.documentElement).getPropertyValue(
            "--aash-tooltip-gap"
          )
        ) || 6;

      if (placement === "top") {
        tooltip.style.left =
          rect.left + rect.width / 2 - tipRect.width / 2 + "px";
        tooltip.style.top = rect.top - tipRect.height - gap + "px";
      }
      if (placement === "bottom") {
        tooltip.style.left =
          rect.left + rect.width / 2 - tipRect.width / 2 + "px";
        tooltip.style.top = rect.bottom + gap + "px";
      }
      if (placement === "right") {
        tooltip.style.left = rect.right + gap + "px";
        tooltip.style.top =
          rect.top + rect.height / 2 - tipRect.height / 2 + "px";
      }
      if (placement === "left") {
        tooltip.style.left = rect.left - tipRect.width - gap + "px";
        tooltip.style.top =
          rect.top + rect.height / 2 - tipRect.height / 2 + "px";
      }
    });

    btn.addEventListener("mouseleave", () => {
      tooltip.classList.remove("show");
    });
  });
  // bootbox modal js
});

/* ========= Accordion ========= */
document.addEventListener("DOMContentLoaded", () => {
  const headers = document.querySelectorAll(".aash-accordion-header");

  headers.forEach((header) => {
    header.addEventListener("click", () => {
      const targetId = header.getAttribute("data-target");
      const body = document.getElementById(targetId);
      const isOpen = header.classList.contains("active");

      // Close all
      headers.forEach((h) => {
        h.classList.remove("active");
        const b = document.getElementById(h.getAttribute("data-target"));
        if (b) {
          b.classList.remove("show");
          b.style.maxHeight = null;
        }
      });

      // Open clicked
      if (!isOpen) {
        header.classList.add("active");
        body.classList.add("show");
        body.style.maxHeight = body.scrollHeight + "px";
      }
    });
  });

  // Initialize default opened
  document.querySelectorAll(".aash-accordion-body.show").forEach((body) => {
    body.style.maxHeight = body.scrollHeight + "px";
  });
});

// single date picker
function AashDatePickerLibrary() {
  // ---------------- SINGLE PICKER ----------------
  const singleInputs = document.querySelectorAll(".aash-datepicker");

  singleInputs.forEach((input) => {
    const wrapper = input.closest(".aash-datepicker-wrapper");
    const icon = wrapper.querySelector(".aash-datepicker-icon");
    const calendarModal = wrapper.querySelector(".aash-calendar-modal");

    let currentDate = new Date();

    function renderCalendar() {
      calendarModal.innerHTML = "";

      // Header
      const header = document.createElement("div");
      header.className = "aash-calendar-header";

      const months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
      ];
      const fullMonths = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
      ];

      const monthSelect = document.createElement("select");
      months.forEach((m, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.text = m;
        if (i === currentDate.getMonth()) opt.selected = true;
        monthSelect.appendChild(opt);
      });
      monthSelect.onchange = (e) => {
        currentDate.setMonth(parseInt(e.target.value));
        renderCalendar();
      };

      const yearSelect = document.createElement("select");
      for (let y = 1900; y <= 2100; y++) {
        const opt = document.createElement("option");
        opt.value = y;
        opt.text = y;
        if (y === currentDate.getFullYear()) opt.selected = true;
        yearSelect.appendChild(opt);
      }
      yearSelect.onchange = (e) => {
        currentDate.setFullYear(parseInt(e.target.value));
        renderCalendar();
      };

      const currentLabel = document.createElement("div");
      currentLabel.className = "aash-calendar-current";
      currentLabel.innerText = fullMonths[currentDate.getMonth()];

      header.appendChild(monthSelect);
      header.appendChild(yearSelect);
      header.appendChild(currentLabel);
      calendarModal.appendChild(header);

      // Grid
      const grid = document.createElement("div");
      grid.className = "aash-calendar-grid";
      ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].forEach((d) => {
        const el = document.createElement("div");
        el.innerText = d;
        el.style.fontWeight = "bold";
        grid.appendChild(el);
      });

      const firstDay = new Date(
        currentDate.getFullYear(),
        currentDate.getMonth(),
        1
      ).getDay();
      const daysInMonth = new Date(
        currentDate.getFullYear(),
        currentDate.getMonth() + 1,
        0
      ).getDate();
      const today = new Date();

      for (let i = 0; i < firstDay; i++)
        grid.appendChild(document.createElement("div"));

      for (let d = 1; d <= daysInMonth; d++) {
        const day = document.createElement("div");
        day.className = "aash-calendar-day";
        day.innerText = d;

        const thisDate = new Date(
          currentDate.getFullYear(),
          currentDate.getMonth(),
          d
        );

        if (thisDate.toDateString() === today.toDateString()) {
          day.classList.add("today");
        }

        day.onclick = () => {
          input.value = thisDate.toLocaleDateString("en-GB");
          calendarModal.style.display = "none";
        };

        grid.appendChild(day);
      }

      calendarModal.appendChild(grid);
    }

    function toggleCalendar() {
      if (calendarModal.style.display === "block") {
        calendarModal.style.display = "none";
      } else {
        renderCalendar();
        calendarModal.style.display = "block";
      }
    }

    input.addEventListener("click", toggleCalendar);
    icon.addEventListener("click", toggleCalendar);

    document.addEventListener("click", (e) => {
      if (!wrapper.contains(e.target)) {
        calendarModal.style.display = "none";
      }
    });
  });
}

// Init
document.addEventListener("DOMContentLoaded", () => {
  AashDatePickerLibrary();
});

// ---------------- RANGE PICKER ----------------
function AashRangeDatePicker() {
  const startInput = document.querySelector(".aash-range-start");
  const endInput = document.querySelector(".aash-range-end");

  const calendarModal = document.createElement("div");
  calendarModal.className = "aash-calendar-modal";
  document.body.appendChild(calendarModal);

  let startDate = null;
  let endDate = null;
  let activeField = null;

  // Open calendar for start or end
  [startInput, endInput].forEach((inp) => {
    inp.addEventListener("click", () => {
      activeField = inp;
      showCalendar();
      const rect = inp.getBoundingClientRect();
      calendarModal.style.position = "absolute";
      calendarModal.style.top = rect.bottom + window.scrollY + "px";
      calendarModal.style.left = rect.left + window.scrollX + "px";
    });
  });

  function renderCalendar(viewDate) {
    const calendar = document.createElement("div");
    calendar.className = "aash-calendar";
    calendar.style.width = "280px";
    // calendar.style.border = "1px solid #ccc";
    calendar.style.borderRadius = "8px";
    calendar.style.background = "#fff";
    // calendar.style.boxShadow = "0 4px 12px rgba(0,0,0,0.1)";
    calendar.style.padding = "10px";

    // header
    const header = document.createElement("div");
    header.className = "aash-calendar-header";
    header.style.display = "flex";
    header.style.alignItems = "center";
    header.style.justifyContent = "space-between";
    header.style.marginBottom = "10px";

    // Left arrow
    const prevBtn = document.createElement("button");
    prevBtn.innerHTML = "&#10094;"; // left chevron
    prevBtn.style.border = "none";
    prevBtn.style.background = "transparent";
    prevBtn.style.cursor = "pointer";
    prevBtn.style.fontSize = "18px";
    prevBtn.style.padding = "4px 8px";
    prevBtn.style.borderRadius = "4px";
    prevBtn.onmouseover = () => (prevBtn.style.background = "#eee");
    prevBtn.onmouseout = () => (prevBtn.style.background = "transparent");
    prevBtn.onclick = () => {
      viewDate.setMonth(viewDate.getMonth() - 1);
      showCalendar(viewDate); // stay open
    };

    // Right arrow
    const nextBtn = document.createElement("button");
    nextBtn.innerHTML = "&#10095;"; // right chevron
    nextBtn.style.border = "none";
    nextBtn.style.background = "transparent";
    nextBtn.style.cursor = "pointer";
    nextBtn.style.fontSize = "18px";
    nextBtn.style.padding = "4px 8px";
    nextBtn.style.borderRadius = "4px";
    nextBtn.onmouseover = () => (nextBtn.style.background = "#eee");
    nextBtn.onmouseout = () => (nextBtn.style.background = "transparent");
    nextBtn.onclick = () => {
      viewDate.setMonth(viewDate.getMonth() + 1);
      showCalendar(viewDate); // stay open
    };

    // Month & Year
    const months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ];
    const monthSelect = document.createElement("select");
    months.forEach((m, i) => {
      const opt = document.createElement("option");
      opt.value = i;
      opt.text = m;
      if (i === viewDate.getMonth()) opt.selected = true;
      monthSelect.appendChild(opt);
    });
    monthSelect.onchange = (e) => {
      viewDate.setMonth(parseInt(e.target.value));
      showCalendar(viewDate);
    };

    const yearSelect = document.createElement("select");
    for (let y = 1900; y <= 2100; y++) {
      const opt = document.createElement("option");
      opt.value = y;
      opt.text = y;
      if (y === viewDate.getFullYear()) opt.selected = true;
      yearSelect.appendChild(opt);
    }
    yearSelect.onchange = (e) => {
      viewDate.setFullYear(parseInt(e.target.value));
      showCalendar(viewDate);
    };

    const middleDiv = document.createElement("div");
    middleDiv.style.display = "flex";
    middleDiv.style.gap = "5px";
    middleDiv.appendChild(monthSelect);
    middleDiv.appendChild(yearSelect);

    header.appendChild(prevBtn);
    header.appendChild(middleDiv);
    header.appendChild(nextBtn);
    calendar.appendChild(header);

    // grid
    const grid = document.createElement("div");
    grid.className = "aash-calendar-grid";
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(7, 1fr)";
    grid.style.textAlign = "center";
    grid.style.gap = "5px";

    ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].forEach((d) => {
      const el = document.createElement("div");
      el.innerText = d;
      el.style.fontWeight = "bold";
      grid.appendChild(el);
    });

    const firstDay = new Date(
      viewDate.getFullYear(),
      viewDate.getMonth(),
      1
    ).getDay();
    const daysInMonth = new Date(
      viewDate.getFullYear(),
      viewDate.getMonth() + 1,
      0
    ).getDate();

    for (let i = 0; i < firstDay; i++)
      grid.appendChild(document.createElement("div"));

    for (let d = 1; d <= daysInMonth; d++) {
      const day = document.createElement("div");
      day.className = "aash-calendar-day";
      day.innerText = d;
      day.style.padding = "6px 0";
      day.style.borderRadius = "4px";
      day.style.cursor = "pointer";

      const thisDate = new Date(viewDate.getFullYear(), viewDate.getMonth(), d);

      // highlight selection
      if (startDate && thisDate.getTime() === startDate.getTime()) {
        day.style.background = "#007BFF";
        day.style.color = "#fff";
      }
      if (endDate && thisDate.getTime() === endDate.getTime()) {
        day.style.background = "#007BFF";
        day.style.color = "#fff";
      }
      if (
        startDate &&
        endDate &&
        thisDate >= startDate &&
        thisDate <= endDate
      ) {
        day.style.background = "#cce5ff";
      }

      // disable invalid end
      if (activeField === endInput && startDate && thisDate < startDate) {
        day.style.color = "#ccc";
        day.style.cursor = "not-allowed";
        day.onclick = null;
      } else {
        day.onclick = () => {
          if (activeField === startInput) {
            startDate = thisDate;
            startInput.value = startDate.toLocaleDateString("en-GB");
          } else if (activeField === endInput) {
            endDate = thisDate;
            endInput.value = endDate.toLocaleDateString("en-GB");
          }
          calendarModal.style.display = "none";
        };
      }

      day.onmouseover = () => {
        if (!day.classList.contains("disabled"))
          day.style.background = "#e0f0ff";
      };
      day.onmouseout = () => {
        if (!day.classList.contains("disabled")) {
          if (
            startDate &&
            endDate &&
            thisDate >= startDate &&
            thisDate <= endDate
          ) {
            day.style.background = "#cce5ff";
          } else if (startDate && thisDate.getTime() === startDate.getTime()) {
            day.style.background = "#007BFF";
            day.style.color = "#fff";
          } else if (endDate && thisDate.getTime() === endDate.getTime()) {
            day.style.background = "#007BFF";
            day.style.color = "#fff";
          } else {
            day.style.background = "transparent";
            day.style.color = "#000";
          }
        }
      };

      grid.appendChild(day);
    }

    calendar.appendChild(grid);
    return calendar;
  }

  function showCalendar(customDate = null) {
    calendarModal.innerHTML = "";
    calendarModal.style.display = "block";

    // Default month: current month
    let baseDate = new Date();
    if (customDate) baseDate = customDate;

    calendarModal.appendChild(renderCalendar(new Date(baseDate)));
  }

  // close on outside click
  document.addEventListener("click", function (e) {
    if (
      !calendarModal.contains(e.target) &&
      e.target !== startInput &&
      e.target !== endInput
    ) {
      calendarModal.style.display = "none";
    }
  });
}

AashRangeDatePicker();

// table jss
document.addEventListener("DOMContentLoaded", function () {
  document.querySelectorAll(".aash-data-table").forEach(initAashDataTable);

  function initAashDataTable(table) {
    // wrapper
    const wrapper = document.createElement("div");
    wrapper.classList.add("aash-datatable-wrapper");
    table.parentNode.insertBefore(wrapper, table);
    wrapper.appendChild(table);

    // Top toolbar (export buttons use aash-btn-export)
    const topToolbar = document.createElement("div");
    topToolbar.classList.add("aash-datatable-top");

    // left side content (only if .aash-export-btn exists)
    let leftContent = "";
    if (table.classList.contains("aash-export-btn")) {
      leftContent = `
    <button class="aash-btn aash-btn-contained aash-btn-export aash-btn-sm" data-export="csv">CSV</button>
    <button class="aash-btn aash-btn-contained aash-btn-export aash-btn-sm" data-export="excel">Excel</button>
    <button class="aash-btn aash-btn-contained aash-btn-export aash-btn-sm" data-export="pdf">PDF</button>
  `;
    }

    topToolbar.innerHTML = `
  <div class="aash-datatable-top-left">
    ${leftContent}
  </div>
  <div class="aash-datatable-top-right">
    <input type="text" class="aash-input searchInput" placeholder="Search...">
  </div>
`;
    wrapper.insertBefore(topToolbar, table);

    // Bottom toolbar (entries + info left, pagination right)
    const bottomToolbar = document.createElement("div");
    bottomToolbar.classList.add("aash-datatable-bottom");
    bottomToolbar.innerHTML = `
      <div class="aash-datatable-bottom-left">
        Show
        <select class="aash-select entriesSelect">
          <option value="5">5</option>
          <option value="10" selected>10</option>
          <option value="25">25</option>
          <option value="50">50</option>
        </select>
        <span class="aash-datatable-info"></span>
      </div>
      <div class="aash-datatable-bottom-right aash-datatable-pagination"></div>
    `;
    wrapper.appendChild(bottomToolbar);

    // state and elements
    const originalRows = Array.from(table.querySelectorAll("tbody tr")); // master list
    const searchInput = topToolbar.querySelector(".searchInput");
    const entriesSelect = bottomToolbar.querySelector(".entriesSelect");
    const info = bottomToolbar.querySelector(".aash-datatable-info");
    const pagination = bottomToolbar.querySelector(
      ".aash-datatable-pagination"
    );
    const headers = Array.from(table.querySelectorAll("thead th"));

    let currentPage = 1;
    let rowsPerPage = parseInt(entriesSelect.value, 10);
    let sortColumn = null;
    let sortAsc = true;

    // attach sort icons and click handlers
    headers.forEach((th, idx) => {
      const span = document.createElement("span");
      span.className = "aash-sort-icon";
      // span.textContent = "↕";
      th.appendChild(span);

      th.style.cursor = "pointer";
      th.addEventListener("click", () => {
        if (sortColumn === idx) sortAsc = !sortAsc;
        else {
          sortColumn = idx;
          sortAsc = true;
        }
        updateSortIcons();
        currentPage = 1;
        renderTable();
      });
    });

    function updateSortIcons() {
      headers.forEach((th, i) => {
        th.classList.remove("sorted-asc", "sorted-desc");
        const icon = th.querySelector(".aash-sort-icon");
        if (i === sortColumn) {
          if (sortAsc) {
            th.classList.add("sorted-asc");
            icon.textContent = "▲";
          } else {
            th.classList.add("sorted-desc");
            icon.textContent = "▼";
          }
          icon.style.opacity = 1;
        } else {
          icon.textContent = "↕";
          icon.style.opacity = 0; // hidden until hover
        }
      });
    }

    // helper: get filtered & sorted rows (entire filtered set, not paginated)
    function getFilteredSortedRows() {
      const q = (searchInput.value || "").toLowerCase().trim();
      let filtered = originalRows.filter((row) =>
        row.textContent.toLowerCase().includes(q)
      );

      // sorting (smart: numeric vs string)
      if (sortColumn !== null) {
        filtered.sort((a, b) => {
          const aRaw = (
            a.children[sortColumn]
              ? a.children[sortColumn].textContent.trim()
              : ""
          ).replace(/\u00A0/g, " ");
          const bRaw = (
            b.children[sortColumn]
              ? b.children[sortColumn].textContent.trim()
              : ""
          ).replace(/\u00A0/g, " ");

          // try numeric comparison
          const aNum = parseFloat(aRaw.replace(/,/g, ""));
          const bNum = parseFloat(bRaw.replace(/,/g, ""));
          if (!isNaN(aNum) && !isNaN(bNum)) {
            return sortAsc ? aNum - bNum : bNum - aNum;
          }

          // fallback: localeCompare with numeric option
          return sortAsc
            ? aRaw.localeCompare(bRaw, undefined, {
                numeric: true,
                sensitivity: "base",
              })
            : bRaw.localeCompare(aRaw, undefined, {
                numeric: true,
                sensitivity: "base",
              });
        });
      }

      return filtered;
    }

    function renderTable() {
      const tbody = table.tBodies[0];
      const filtered = getFilteredSortedRows();

      const total = filtered.length;
      const totalPages = Math.max(1, Math.ceil(total / rowsPerPage));
      if (currentPage > totalPages) currentPage = totalPages;

      const start = (currentPage - 1) * rowsPerPage;
      const end = start + rowsPerPage;

      // clear and append sorted paginated rows (this reorders DOM for correct sort)
      tbody.innerHTML = "";
      filtered.slice(start, end).forEach((r) => tbody.appendChild(r));

      // info text (handle 0 rows)
      if (total === 0) info.textContent = "No entries to show";
      else
        info.textContent = ` Showing ${start + 1} to ${Math.min(
          end,
          total
        )} of ${total} entries`;

      renderPagination(totalPages);
    }

    function renderPagination(totalPages) {
      pagination.innerHTML = "";

      const prev = createPageBtn("Previous", currentPage > 1, () => {
        currentPage--;
        renderTable();
      });
      pagination.appendChild(prev);

      // compact/ellipsis pagination for long lists: show first, last, neighbors
      const maxButtons = 7; // total numeric buttons to show (tweakable)
      if (totalPages <= maxButtons) {
        for (let i = 1; i <= totalPages; i++)
          pagination.appendChild(pageButton(i));
      } else {
        // always show first
        pagination.appendChild(pageButton(1));

        const left = Math.max(2, currentPage - 2);
        const right = Math.min(totalPages - 1, currentPage + 2);

        if (left > 2) {
          const dots = document.createElement("span");
          dots.textContent = " … ";
          dots.style.padding = "0 6px";
          pagination.appendChild(dots);
        }

        for (let i = left; i <= right; i++)
          pagination.appendChild(pageButton(i));

        if (right < totalPages - 1) {
          const dots = document.createElement("span");
          dots.textContent = " … ";
          dots.style.padding = "0 6px";
          pagination.appendChild(dots);
        }

        // always show last
        pagination.appendChild(pageButton(totalPages));
      }

      const next = createPageBtn("Next", currentPage < totalPages, () => {
        currentPage++;
        renderTable();
      });
      pagination.appendChild(next);
    }

    function pageButton(i) {
      const btn = createPageBtn(i, true, () => {
        currentPage = i;
        renderTable();
      });
      if (i === currentPage) btn.classList.add("active");
      return btn;
    }

    function createPageBtn(text, enabled, onClick) {
      const btn = document.createElement("button");
      btn.textContent = text;
      btn.className = "aash-btn aash-btn-sm aash-pagination-btn";
      if (!enabled) btn.disabled = true;
      btn.addEventListener("click", onClick);
      return btn;
    }

    // events
    searchInput.addEventListener("input", () => {
      currentPage = 1;
      renderTable();
    });
    entriesSelect.addEventListener("change", () => {
      rowsPerPage = parseInt(entriesSelect.value, 10);
      currentPage = 1;
      renderTable();
    });

    // export (exports ENTIRE filtered dataset, not only current page)
    topToolbar.querySelectorAll("[data-export]").forEach((btn) => {
      btn.addEventListener("click", () => {
        const type = btn.dataset.export;
        exportFiltered(type);
      });
    });

    function exportFiltered(type) {
      const filtered = getFilteredSortedRows();
      const headerRow = Array.from(table.tHead.rows[0].cells).map((c) =>
        c.textContent.trim()
      );

      // map rows -> text cells
      const dataRows = filtered.map((row) =>
        Array.from(row.children).map((c) => c.textContent.trim())
      );

      if (type === "csv") {
        const csv = [headerRow, ...dataRows]
          .map((r) =>
            r.map((cell) => `"${cell.replace(/"/g, '""')}"`).join(",")
          )
          .join("\n");
        downloadFile(csv, "table.csv", "text/csv");
      } else if (type === "excel") {
        // simple excel via tab-separated values
        const tsv = [headerRow, ...dataRows]
          .map((r) => r.map((cell) => cell.replace(/\t/g, " ")).join("\t"))
          .join("\n");
        downloadFile(tsv, "table.xls", "application/vnd.ms-excel");
      } else if (type === "pdf") {
        // minimal printable view (you can integrate jsPDF later if needed)
        const printable = [headerRow, ...dataRows]
          .map((r) => r.join(" | "))
          .join("\n");
        const w = window.open("", "_blank");
        w.document.write(
          "<pre style='font-family:monospace;'>" +
            escapeHtml(printable) +
            "</pre>"
        );
        w.print();
        w.close();
      }
    }

    function downloadFile(content, filename, mime) {
      const blob = new Blob([content], { type: mime });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      link.remove();
    }

    function escapeHtml(s) {
      return s
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    // initial render
    renderTable();
  }
});

// toastify js
function showToast(
  message,
  type = "info",
  duration = 4000,
  position = "top-right"
) {
  // Create/find container
  let container = document.querySelector(`.aash-toast-container.${position}`);
  if (!container) {
    container = document.createElement("div");
    container.className = `aash-toast-container ${position}`;
    document.body.appendChild(container);
  }

  // Create toast
  const toast = document.createElement("div");
  toast.className = `aash-toast aash-toast-${type}`;
  toast.innerHTML = `
    <div style="width:100%;display:flex;justify-content:space-between;align-items:center;">
      <span>${message}</span>
      <button onclick="this.parentElement.parentElement.remove()">×</button>
    </div>
    <div class="aash-toast-progress"></div>
  `;

  // Add progress animation duration
  const progress = toast.querySelector(".aash-toast-progress");
  progress.style.animationDuration = duration + "ms";

  container.appendChild(toast);

  // Auto remove
  setTimeout(() => {
    toast.style.animation = "fadeOut 0.5s forwards";
    setTimeout(() => toast.remove(), 500);
  }, duration);
}

// bootbox js
const AashBox = (() => {
  function createModal(options) {
    document
      .querySelectorAll(".aash-modal-backdrop")
      .forEach((e) => e.remove());

    const backdrop = document.createElement("div");
    backdrop.className = "aash-modal-backdrop";

    const modal = document.createElement("div");
    modal.className = "aash-modal show aash-modal-top";

    modal.innerHTML = `
      <div class="aash-modal-dialog ${
        options.centerVertical ? "aash-modal-centered" : ""
      }">
        <div class="aash-modal-header">
          <span>${options.title || "Message"}</span>
          <button class="btn-close" data-close="aash-modal">✖</button>
        </div>
        <div class="aash-modal-body">${options.message || ""}</div>
        <div class="aash-modal-footer"></div>
      </div>
    `;

    const footer = modal.querySelector(".aash-modal-footer");

    if (options.buttons) {
      Object.keys(options.buttons).forEach((key) => {
        const btn = options.buttons[key];
        const b = document.createElement("button");
        b.innerText = btn.label || key;
        b.className = btn.className || "";
        b.onclick = () => {
          if (btn.callback) {
            btn.callback();
          } else {
            if (options.callback) options.callback(key === "confirm");
          }
          backdrop.remove();
        };
        footer.appendChild(b);
      });
    }

    modal.querySelectorAll("[data-close]").forEach((el) => {
      el.onclick = () => backdrop.remove();
    });

    backdrop.appendChild(modal);
    document.body.appendChild(backdrop);
  }

  function renderInput(field, idx) {
    const inputId = `aashPrompt_${Date.now()}_${idx}`;
    let html = `<div class="aash-field"><label>${
      field.label || ""
    }</label><br/>`;

    if (field.inputType === "select") {
      html += `<select id="${inputId}" class="aash-input" ${
        field.required ? "required" : ""
      }>`;
      (field.inputOptions || []).forEach((opt) => {
        html += `<option value="${opt.value}" ${
          opt.value === field.value ? "selected" : ""
        }>${opt.text}</option>`;
      });
      html += `</select>`;
    } else if (field.inputType === "radio" || field.inputType === "checkbox") {
      (field.inputOptions || []).forEach((opt, i) => {
        const id = `${inputId}_${i}`;
        html += `
          <label>
            <input type="${
              field.inputType
            }" name="${inputId}" id="${id}" value="${opt.value}"
              ${
                field.value &&
                (Array.isArray(field.value)
                  ? field.value.includes(opt.value)
                  : field.value === opt.value)
                  ? "checked"
                  : ""
              } 
              ${field.required ? "required" : ""} />
            ${opt.text}
          </label><br/>`;
      });
    } else {
      html += `<input type="${
        field.inputType || "text"
      }" id="${inputId}" value="${field.value || ""}" class="aash-input"
        ${field.required ? "required" : ""}
        ${field.minLength ? `minlength="${field.minLength}"` : ""}
        ${field.maxLength ? `maxlength="${field.maxLength}"` : ""}
        ${field.pattern ? `pattern="${field.pattern}"` : ""}
      />`;
    }

    html += `<div class="aash-error" id="${inputId}_error" style="color:red;font-size:12px;"></div>`;
    html += `</div>`;
    return { html, inputId, field };
  }

  function validateField(inputId, field) {
    const el = document.getElementById(inputId);
    const errorEl = document.getElementById(inputId + "_error");
    if (!el) return true;

    let value = el.value.trim();
    let error = "";

    if (field.required && !value) {
      error = `${field.label || "This field"} is required`;
    } else if (field.minLength && value.length < field.minLength) {
      error = `${field.label} must be at least ${field.minLength} characters`;
    } else if (field.maxLength && value.length > field.maxLength) {
      error = `${field.label} must be less than ${field.maxLength} characters`;
    } else if (field.pattern) {
      const regex = new RegExp(field.pattern);
      if (!regex.test(value)) error = `${field.label} is invalid`;
    }

    errorEl.innerText = error;
    return !error;
  }

  return {
    alert(opts) {
      if (typeof opts === "string") opts = { message: opts };
      createModal({
        title: opts.title || "Alert",
        message: opts.message || "",
        buttons: opts.buttons || {
          ok: {
            label: opts.okLabel || "OK",
            className:
              "aash-btn aash-btn-sm aash-btn-contained aash-btn-success",
            callback: opts.callback,
          },
        },
      });
    },

    confirm(opts) {
      createModal({
        title: opts.title || "Confirm",
        message: opts.message || "",
        centerVertical: opts.centerVertical,
        buttons: opts.buttons || {
          cancel: {
            label: opts.cancelLabel || "Cancel",
            className:
              "aash-btn aash-btn-error aash-btn-sm aash-btn-contained me-2",
          },
          confirm: {
            label: opts.confirmLabel || "OK",
            className:
              "aash-btn aash-btn-success aash-btn-sm aash-btn-contained",
          },
        },
        callback: opts.callback,
      });
    },

    prompt(opts) {
      const fieldConfigs = Array.isArray(opts.fields) ? opts.fields : [opts];
      const inputs = fieldConfigs.map((f, i) => renderInput(f, i));

      createModal({
        title: opts.title || "Prompt",
        message: `<form>${inputs.map((i) => i.html).join("")}</form>`,
        centerVertical: opts.centerVertical,
        buttons: {
          cancel: {
            label: opts.cancelLabel || "Cancel",
            className:
              "aash-btn aash-btn-error aash-btn-sm aash-btn-contained me-2",
          },
          confirm: {
            label: opts.confirmLabel || "Submit",
            className:
              "aash-btn aash-btn-success aash-btn-sm aash-btn-contained",
            callback: function () {
              let valid = true;
              inputs.forEach((input) => {
                if (!validateField(input.inputId, input.field)) valid = false;
              });
              if (!valid) return;

              const values = {};
              inputs.forEach((input) => {
                const { inputId, field } = input;
                if (field.inputType === "checkbox") {
                  values[field.name || inputId] = [
                    ...document.querySelectorAll(
                      `input[name='${inputId}']:checked`
                    ),
                  ].map((i) => i.value);
                } else if (field.inputType === "radio") {
                  const sel = document.querySelector(
                    `input[name='${inputId}']:checked`
                  );
                  values[field.name || inputId] = sel ? sel.value : null;
                } else {
                  const el = document.getElementById(inputId);
                  values[field.name || inputId] = el ? el.value.trim() : null;
                }
              });

              opts.callback && opts.callback(values);
            },
          },
        },
      });

      setTimeout(() => {
        const firstId = inputs[0]?.inputId;
        if (firstId) document.getElementById(firstId)?.focus();
      }, 100);
    },
  };
})();

// file upload js and multifile upload js
// Validation sizes
const SIZE_200KB = 200 * 1024;
const SIZE_2MB = 2 * 1024 * 1024;
const SIZE_500KB = 500 * 1024;
const SIZE_20MB = 20 * 1024 * 1024;
const MAX_FILES = 7;

function validateFile(file, allowed, minSize, maxSize) {
  const ext = file.name.split(".").pop().toLowerCase();
  if (!allowed.includes(ext))
    return { valid: false, reason: `Invalid type: .${ext}` };
  if (file.size < minSize)
    return { valid: false, reason: `${file.name} too small` };
  if (file.size > maxSize)
    return { valid: false, reason: `${file.name} too large` };
  return { valid: true };
}

// Fake progress simulation
function simulateProgress(bar) {
  let progress = 0;
  const interval = setInterval(() => {
    progress += Math.random() * 20;
    if (progress >= 100) {
      progress = 100;
      clearInterval(interval);
    }
    bar.style.width = progress + "%";
  }, 300);
}

function setupUpload(
  input,
  boxId,
  allowed,
  minSize,
  maxSize,
  allowMultiple,
  icon
) {
  const box = document.getElementById(boxId);
  const label = box.querySelector(".upload-label");

  input.addEventListener("change", () => {
    const files = Array.from(input.files);
    let validFiles = [];
    let invalidReasons = [];

    if (!allowMultiple) {
      box.querySelectorAll(".file-chip").forEach((chip) => chip.remove());
    }

    if (!allowMultiple && files.length > 1) {
      showToast("Multiple files not allowed", "error", 2000, "top-right");
      input.value = "";
      return;
    }

    if (allowMultiple) {
      const existingCount = box.querySelectorAll(".file-chip").length;
      if (existingCount + files.length > MAX_FILES) {
        showToast(
          `You can only upload max ${MAX_FILES} files`,
          "error",
          2000,
          "top-right"
        );
        input.value = "";
        return;
      }
    }

    files.forEach((file) => {
      const { valid, reason } = validateFile(file, allowed, minSize, maxSize);
      if (valid) {
        validFiles.push(file);
      } else {
        invalidReasons.push(reason);
      }
    });

    // Show a single toast for all invalids
    if (invalidReasons.length) {
      showToast(invalidReasons.join(", "), "error", 2000, "top-right");
    }

    // Build chips for valid files
    validFiles.forEach((file) => {
      const chip = document.createElement("div");
      chip.className = "file-chip";
      chip.innerHTML = `
            <i class="fa-solid ${icon}"></i>
            <span>${file.name}</span>
            <i class="fa-solid fa-xmark remove-btn"></i>
            <div class="progress"></div>
          `;
      box.appendChild(chip);

      const bar = chip.querySelector(".progress");
      simulateProgress(bar);

      chip.querySelector(".remove-btn").addEventListener("click", () => {
        chip.remove();
        if (box.querySelectorAll(".file-chip").length === 0) {
          label.style.display = "flex"; // show label again
        }
        showToast(` Removed ${file.name}`, "error", 2000, "top-right");
      });
    });

    // Show one toast for all valid files
    // Show one toast for all valid files
    if (validFiles.length) {
      if (!allowMultiple) {
        // Single file upload → show file name
        showToast(
          `✅ ${validFiles[0].name} ready for upload`,
          "success",
          2000,
          "top-right"
        );
      } else {
        // Multiple file upload → show count
        showToast(
          `✅ ${validFiles.length} file(s) ready for upload`,
          "success",
          2000,
          "top-right"
        );
      }
      label.style.display = "none";
    } else {
      // If no valid files, keep label visible
      if (box.querySelectorAll(".file-chip").length === 0) {
        label.style.display = "flex";
      }
    }
  });
}

// Documents
document.querySelectorAll(".doc-upload").forEach((input) => {
  const allowMultiple = input.hasAttribute("multiple");
  if (allowMultiple) input.setAttribute("multiple", "true");
  setupUpload(
    input,
    "docBox",
    ["pdf", "doc", "docx", "xls", "xlsx"],
    SIZE_200KB,
    SIZE_2MB,
    allowMultiple,
    "fa-file-word"
  );
});

// Images
document.querySelectorAll(".img-upload").forEach((input) => {
  const allowMultiple = input.hasAttribute("multiple");
  if (allowMultiple) input.setAttribute("multiple", "true");
  setupUpload(
    input,
    "imgBox",
    ["jpg", "jpeg", "png"],
    SIZE_200KB,
    SIZE_2MB,
    allowMultiple,
    "fa-image"
  );
});

// Videos (always single)
document.querySelectorAll(".video-upload").forEach((input) => {
  setupUpload(
    input,
    "videoBox",
    ["mp4", "webm", "avi", "mov"],
    SIZE_500KB,
    SIZE_20MB,
    false,
    "fa-video"
  );
});

/* ========= End of aashdit.min.js ========= */
